#|
 This file is a part of glsl-parser
 (c) 2017 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(in-package #:org.shirakumo.trial.glsl.parser)

(defstruct (environment (:conc-name NIL)
                        (:constructor %make-environment)
                        (:copier NIL))
  (root NIL)
  (bindings (make-hash-table :test 'equal)))

(defun make-environment (&optional root)
  (let ((environment (%make-environment)))
    (cond (root
           (setf (root environment) root)
           (loop for k being the hash-keys of root
                 for v being the hash-values of root
                 do (setf (gethash k (bindings environment)) v)))
          (T
           (setf (root environment) environment)))
    environment))

(defun constant-p (value environment)
  (declare (ignore environment))
  (or (integerp value)
      (floatp value)
      (and (consp value) (eql 'unsigned-int (first value)))))

(defun variable-p (value environment)
  (let ((binding (gethash value (bindings environment))))
    (and binding
         (not (eql :function (first binding))))))

(defun function-p (value environment)
  (let ((binding (gethash value (bindings environment))))
    (and binding
         (eql :function (first binding)))))

(defun expression-p (value environment)
  )

(defun statement-p (value environment)
  )

(defun global-p (value environment)
  (not (null (gethash value (bindings (root environment))))))

(defun control-flow-p (value environment)
  (declare (ignore environment))
  (and (consp value)
       (find (first value) '(selection-statement
                             case-label
                             switch-statement
                             while-statement
                             do-statement
                             for-statement
                             continue
                             break
                             return
                             discard))))

(defun walk (ast function &optional (environment (make-environment)))
  (etypecase ast
    ((or integer float keyword string null (eql #.no-value))
     (funcall function ast environment))
    (cons
     (with-object-case part 
       (unsigned-int (int)
        (funcall function ast environment))
       (preprocessor-directive (directive)
        )
       (modified-reference (expression &rest modifiers)
        )
       (field-modifier (identifier)
        )
       (array-modifier (expression)
        )
       (increment-modifier ()
        )
       (decrement-modifier ()
        )
       (call-modifier (&rest values)
        )
       (same-+ (expression)
        )
       (negation (expression)
        )
       (inversion (expression)
        )
       (bit-inversion (expression)
        )
       (prefix-increment (expression)
        )
       (prefix-decrement (expression)
        )
       (multiplication (left right)
        )
       (division (left right)
        )
       (modulus (left right)
        )
       (addition (left right)
        )
       (subtraction (left right)
        )
       (left-shift (left right)
        )
       (right-shift (left right)
        )
       (less-than (left right)
        )
       (greater-than (left right)
        )
       (less-equal-than (left right)
        )
       (greater-equal-than (left right)
        )
       (equal (left right)
        )
       (not-equal (left right)
        )
       (bitwise-and (left right)
        )
       (exclusive-or (left right)
        )
       (inclusive-or (left right)
        )
       (logical-and (left right)
        )
       (logical-xor (left right)
        )
       (logical-or (left right)
        )
       (conditional (condition expression else)
        )
       (assignment (place op value)
        )
       (multiple-expressions (&rest expressions)
        )
       (function-declaration (prototype)
        )
       (function-prototype (qualifier specifier identifier &rest parameters)
        )
       (precision-declarator (precision type)
        )
       (variable-declaration (qualifier specifier &rest initializers)
        )
       (layout-qualifier (&rest ids)
        )
       (layout-qualifier-id (identifier &optional value)
        )
       (type-qualifier (&rest qualifiers)
        )
       (subroutine-qualifier (&optional type-name)
        )
       (type-specifier (type &optional array)
        )
       (array-specifier (&rest specifiers)
        )
       (type-name (identifier)
        )
       (struct-specifier (identifier &rest declarations)
        )
       (struct-declaration (qualifier specifier &rest declarators)
        )
       (array-initializer (initializer &rest initializers)
        )
       (compound-statement (&rest statements)
        )
       (selection-statement (expression statement &optional else)
        )
       (condition-declarator (qualifier specifier identifier initializer)
        )
       (switch-statement (expression statement)
        )
       (case-label (case)
        )
       (while-statement (condition statement)
        )
       (do-statement (statement expression)
         )
       (for-statement (declaration condition expression statement)
        )
       (continue ()
        )
       (break ()
        )
       (return (&optional value)
               )
       (discard ()
        )
       (function-definition (prototype statement)
        )
       (shader (&rest items)
        )))))
