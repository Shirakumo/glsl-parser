#|
 This file is a part of glsl-parser
 (c) 2017 Shirakumo http://tymoon.eu (shinmera@tymoon.eu)
 Author: Nicolas Hafner <shinmera@tymoon.eu>
|#

(in-package #:org.shirakumo.trial.glsl.parser)

(defvar *serialize-stream*)

(defun serialize (part &optional to)
  (etypecase to
    (null
     (with-output-to-string (*serialize-stream*)
       (serialize-part part)))
    ((eql T)
     (let ((*serialize-stream* *standard-output*))
       (serialize-part part)
       to))
    (stream
     (let ((*serialize-stream* to))
       (serialize-part part)
       to))
    (pathname
     (with-open-file (*serialize-stream* to :direction :output)
       (serialize-part part)
       to))))

(defun sformat (string &rest args)
  (format *serialize-stream* "~?" (compile-format-string string) args))

(define-compiler-macro sformat (string &rest args)
  `(format *serialize-stream* ,(compile-format-string string) ,@args))

(defun %format-object (s a cp at)
  (declare (ignore cp at))
  (let ((*serialize-stream* s))
    (serialize-part a)))

(defvar *indent* 0)

(defmacro with-indentation ((&optional (step 2)) &body body)
  `(let ((*indent* (+ ,step *indent*)))
     ,@body))

(defun indent ()
  (fresh-line *serialize-stream*)
  (format *serialize-stream* "~v{ ~}" *indent* 0))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun compile-format-string (string)
    (with-output-to-string (out)
      (loop for i from 0 below (length string)
            do (cond ((and (char= #\~ (char string i))
                           (char= #\o (char string (1+ i))))
                      (write-string "~/ORG.SHIRAKUMO.TRIAL.GLSL.PARSER::%FORMAT-OBJECT/" out)
                      (incf i))
                     (T
                      (write-char (char string i) out)))))))

(defun preprocessor-p (thing)
  (and (consp thing) (eql (first thing) 'preprocessor-directive)))

(defun serialize-part (part)
  (etypecase part
    (integer
     (sformat "~d" part))
    (float
     (sformat "~f~@[lf~]" part (typep part 'double-float)))
    (keyword
     (sformat "~a" (find part *glsl-keywords* :test #'string-equal)))
    (string
     (sformat "~a" part))
    (null)
    ((eql #.no-value))
    (cons
     (with-object-case part 
       (unsigned-int (int)
        (serialize-part int)
        (sformat "u"))
       (preprocessor-directive (directive)
        (sformat "~&~a~%" directive))
       (modified-reference (expression &rest modifiers)
        (sformat "~o~{~o~}" expression modifiers))
       (field-modifier (identifier)
        (sformat ".~o" identifier))
       (array-modifier (expression)
        (sformat "[~o]" expression))
       (increment-modifier ()
        (sformat "++"))
       (decrement-modifier ()
        (sformat "--"))
       (call-modifier (&rest values)
        (sformat "(~{~o~^, ~})" values))
       (same-+ (expression)
        (sformat "+~o" expression))
       (negation (expression)
        (sformat "-~o" expression))
       (inversion (expression)
        (sformat "!~o" expression))
       (bit-inversion (expression)
        (sformat "~~~o" expression))
       (prefix-increment (expression)
        (sformat "++~o" expression))
       (prefix-decrement (expression)
        (sformat "--~o" expression))
       (multiplication (left right)
        (sformat "(~o * ~o)" left right))
       (division (left right)
        (sformat "(~o / ~o)" left right))
       (modulus (left right)
        (sformat "(~o % ~o)" left right))
       (addition (left right)
        (sformat "(~o + ~o)" left right))
       (subtraction (left right)
        (sformat "(~o - ~o)" left right))
       (left-shift (left right)
        (sformat "(~o << ~o)" left right))
       (right-shift (left right)
        (sformat "(~o >> ~o)" left right))
       (less-than (left right)
        (sformat "(~o < ~o)" left right))
       (greater-than (left right)
        (sformat "(~o > ~o)" left right))
       (less-equal-than (left right)
        (sformat "(~o <= ~o)" left right))
       (greater-equal-than (left right)
        (sformat "(~o >= ~o)" left right))
       (equal (left right)
        (sformat "(~o == ~o)" left right))
       (not-equal (left right)
        (sformat "(~o != ~o)" left right))
       (bitwise-and (left right)
        (sformat "(~o & ~o)" left right))
       (exclusive-or (left right)
        (sformat "(~o ^ ~o)" left right))
       (inclusive-or (left right)
        (sformat "(~o | ~o)" left right))
       (logical-and (left right)
        (sformat "(~o && ~o)" left right))
       (logical-xor (left right)
        (sformat "(~o ^^ ~o)" left right))
       (logical-or (left right)
        (sformat "(~o || ~o)" left right))
       (conditional (condition expression else)
        (sformat "~o? ~o :~o" condition expression else))
       (assignment (place op value)
        (sformat "~o ~a ~o" place op value))
       (multiple-expressions (&rest expressions)
        (sformat "~{~o~^, ~}" expressions))
       (function-declaration (prototype)
        (sformat "~o" prototype))
       (function-prototype (qualifier specifier identifier &rest parameters)
        (sformat "~o~o ~o(~{~{~o~^ ~}~^, ~})"
                 qualifier specifier identifier parameters))
       (precision-declarator (precision type)
        (sformat "precision ~o ~o" precision type))
       (variable-declaration (qualifier specifier identifier array &optional initializer)
        (sformat "~o~o ~o~o~@[ = ~o~]" qualifier specifier identifier array initializer))
       (layout-qualifier (&rest ids)
        (sformat "layout(~{~o~^, ~})" ids))
       (layout-qualifier-id (identifier &optional value)
        (sformat "~o~@[ = ~o~]" identifier value))
       (type-qualifier (&rest qualifiers)
        (sformat "~{~o ~}" qualifiers))
       (subroutine-qualifier (&optional type-name)
        (sformat "subroutine~@[(~o)~]" type-name))
       (type-specifier (type &optional array)
        (sformat "~o~@[~o~]" type array))
       (array-specifier (&rest specifiers)
        (sformat "~:[[]~;~:*~{[~o]~}~]" specifiers))
       (type-name (identifier)
        (sformat "~o" identifier))
       (struct-specifier (identifier)
        (sformat "struct ~o" identifier))
       (struct-declaration (identifier &rest declarators)
        (sformat "struct ~o{~{~o~}}" identifier declarators))
       (struct-declarator (qualifier specifier &rest fields)
        (sformat "~o~o~{~{~o~^ ~}~^, ~};" qualifier specifier fields))
       (array-initializer (initializer &rest initializers)
        (sformat "{~o~{, ~o~}}" initializer initializers))
       (multiple-statements (&optional statement &rest statements)
        (when statement
          (sformat "~o" statement)
          (loop for statement in statements
                do (sformat ";") (indent) (sformat "~o" statement))))
       (compound-statement (&rest statements)
        (sformat "{")
        (with-indentation ()
          (dolist (statement statements)
            (cond ((preprocessor-p statement)
                   (sformat "~o" statement))
                  (T
                   (indent) (sformat "~o;" statement)))))
        (indent) (sformat "}"))
       (selection-statement (expression statement &optional else)
        (sformat "if(~o)~o~@[else~o~]" expression statement else))
       (condition-declarator (qualifier specifier identifier initializer)
        (sformat "~o~o ~o = ~o" qualifier specifier identifier initializer))
       (switch-statement (expression statement)
        (sformat "switch(~o)~o" expression statement))
       (case-label (case)
        (if (eql :default case)
            (sformat "default: ")
            (sformat "case ~o: " case)))
       (while-statement (condition statement)
        (sformat "while(~o)~o" condition statement))
       (do-statement (statement expression)
         (sformat "do~o" statement)
         (indent) (sformat "while(~o)" expression))
       (for-statement (declaration condition expression statement)
        (sformat "for(~o; ~o; ~o)~o" declaration condition expression statement))
       (continue ()
        (sformat "continue"))
       (break ()
        (sformat "break"))
       (return (&optional value)
        (sformat "return~@[ ~o~]" value))
       (discard ()
        (sformat "discard"))
       (function-definition (prototype statement)
        (sformat "~%~o~o" prototype statement))
       (shader (&rest items)
        (dolist (item items)
          (cond ((preprocessor-p item)
                 (serialize-part item))
                (T
                 (indent)
                 (serialize-part item)
                 (sformat ";")))))))))
